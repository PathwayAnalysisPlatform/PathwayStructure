#' Make a reduced .sif file.
#'
#' The input file is read, and only the requested edgeTypes
#' are retained. The result file contains only one line
#' for each protein that is the start of one of those
#' edges.
#' The output file has only one type of edge, as all edges
#' are mixed anyway, and Francisco's graph implementation
#' needs an edge type.
#'
#' @param inFile an .sif file as generated by
#' PathwayQuery, ProteinGraphExtractor
#' @param outFile the name of the output file
#' @param edgeTypes a character vector containing the
#' types of edges to retain
makeDirected <- function (inFile, outFile, edgeTypes) {
    inFileList <- readFile(inFile)
    connections <- getConnections(inFileList, edgeTypes)
    proteinNames <- writeFile(outFile, connections)
    length(proteinNames)
    ## writeFile(outFile,
    ##           getConnections(readFile(inFile),
    ##                          edgeTypes))
}

#' Read a .sif file, as made using PathwayQuery, ProteinGraphExtractor,
#' and output this file as a list of lists.
#'
#' The first level of the list has nodes with 'outgoing' edges
#' (the first column in the sif file) as keys. These all contain
#' lists which have the type of connection (i.e. "io", "oi", "ci", etc;
#' the second column in the sif file) as keys, and a vector of
#' nodes/proteins as the values.
#'
#' @param inFile the sif file to read from
#' @return a list of lists, having silimar structure as the inFile
readFile <- function (inFile) {
    fileOutputList <- list()
    ## will be fileOutputList[[typeConnection]][[startNode]]
    con <- file(inFile, "r")
    while ( TRUE ) {
        line <- readLines(con, n = 1)
        if ( length(line) == 0 ) {
            break
        }
        theLine <- strsplit(line, " ")[[1]]
        theNode <- theLine[1]
        typeConn <- theLine[2]
        fileOutputList[[typeConn]][[theNode]] <-
            theLine[3:length(theLine)]
    }
    close(con)
    fileOutputList
}


#' Get the names of the source nodes from the inFile,
#' possibly for only a subset of the connection types.
#'
#' @param inFileList the list of connections,
#' as generated by \code{readFile} above
#' @param connTypes a vector of connection types, such as
#' \code{c("io", "co", "ro")} or \code{"oi", "oc", "or"}.
#' If \code{NULL}, all connection types are used.
#' @return a vector containing all nodes which are the source
#' of an edge for a pair of nodes
sources <- function (inFileList, connTypes = NULL) {
    if (is.null(connTypes)) {
        unique(
            unlist(
                lapply(names(inFileList),
                       function (x) {
                           names(inFileList[[x]])
                       })))
    } else {
        unique(
            unlist(
                lapply(connTypes,
                       function (x) {
                           names(inFileList[[x]])
                       })))
    }
}

#' Get a list with, for each node, a vector of end nodes
#' containing the end-nodes of all the connection types
#' requested.
#'
#' the output is a list, with the start-nodes of the requested
#' connections as keys. Each start-node has one vector
#' with all the other nodes which can be reached through an
#' edge of (at least) one of the types specified in \code{connTypes}
#'
#' @param inFileList the list of connections,
#' as generated by \code{readFile} above
#' @param connTypes a vector of connection types, such as
#' \code{c("io", "co", "ro")} or \code{"oi", "oc", "or"}.
#' If \code{NULL}, all connection types are used.
#' @return a list containing, for each node, all nodes
#' which can be reached from that node, through an edge
#' of at least one of the types specified in \{connTypes}.
#' Nodes which can not reach any other node in that way
#' will not be a key in this list.
getConnections <- function (inFileList, connTypes = NULL) {
    connections <- list()
    for (name in sources(inFileList, connTypes)) {
        temp <- c()
        for (x in connTypes) {
            if (name %in% names(inFileList[[x]])) {
                temp <- c(temp, inFileList[[x]][[name]])
            }
        }
        connections[[name]] <- unique(temp)
    }
    connections
}

#' Write an .sif file from the list of connections
#' generated by \code{getConnections}.
#'
#' The type of connection will be "io" for all proteins,
#' because the graph implementation of Francisco needs a
#' connection type.
#'
#' The total number of proteins and the number of
#' source-nodes will be printed.
#'
#' @param outFile name of the file to write to.
#' @param connections the list of connections as
#' generated by \code{getConnections}.
#' @return a vector containing the names of all proteins,
#' including those which are not source-nodes
writeFile <- function (outFile, connections) {
    con <- file(outFile, "w")
    for (name in names(connections)) {
        writeLines(paste(name,
                         "io", ## because F's code for graphs
                         paste(connections[[name]],
                               collapse = " ")),
                   con)
    }
    close(con)

    ## make a vector with all the proteins
    ## including the nodes which are not source nodes
    proteinNames <- unique(c(sources, unlist(connections)))

    print(paste(length(proteinNames), "proteins"))
    print(paste("of which", length(names(connections)), "sources"))

    proteinNames
}
