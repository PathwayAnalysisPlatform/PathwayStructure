package no.uib.conversion;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.stream.Collectors;
import java.util.zip.GZIPOutputStream;

/**
 * This class exports a sif file as generated by PathwayMapper into an igraph
 * data structure.
 *
 * @author Marc Vaudel
 */
public class SifToIGraph {

    /**
     * The main method takes a sif file as generated by PathwayMapper and writes
     * igraph files.
     *
     * @param args the arguments
     */
    public static void main(String[] args) {

        try {

            args = new String[]{"C:\\Projects\\Bram\\graphs\\ProteomeGraph.sif",
                "C:\\Github\\post-association\\resources\\function\\reactome",
                "reactome_18.08.17"};

            SifToIGraph exportGraphData = new SifToIGraph();

            HashSet<String> restrictionList;
            File outputFolder;
            String baseName;

            System.out.println(new Date() + " Parsing list");

            if (args.length == 4) {

                File restrictionFile = new File(args[1]);
                restrictionList = exportGraphData.parseRestrictionFile(restrictionFile);
                outputFolder = new File(args[2]);
                baseName = args[3];

            } else if (args.length == 3) {

                restrictionList = null;
                outputFolder = new File(args[1]);
                baseName = args[2];

            } else {

                throw new IllegalArgumentException("3 or 4 arguments expected.");

            }

            File sifFile = new File(args[0]);

            System.out.println(new Date() + " Parsing sif file");

            exportGraphData.parseSif(sifFile, restrictionList);

            System.out.println(new Date() + " Exporting results");
            exportGraphData.writeIGraphFiles(outputFolder, baseName);

        } catch (Exception e) {

            e.printStackTrace();

        }
    }

    /**
     * Map of reactions, from input to outputs.
     */
    private HashMap<String, HashSet<String>> reaction = new HashMap<>();
    /**
     * Map of regulators, from input to outputs.
     */
    private HashMap<String, HashSet<String>> regulation = new HashMap<>();
    /**
     * Map of catalyzers, from input to outputs.
     */
    private HashMap<String, HashSet<String>> catalysis = new HashMap<>();
    /**
     * Map of complexes, from input to outputs.
     */
    private HashMap<String, HashSet<String>> complex = new HashMap<>();
    /**
     * Set of all nodes.
     */
    private HashSet<String> allNodes = new HashSet<>();
    /**
     * Encoding.
     */
    public static final String encoding = "UTF-8";

    /**
     * Parses accessions from a restriction file, one accession per line.
     *
     * @param restrictionFile the restriction file
     *
     * @return the restriction accessions as a set
     *
     * @throws IOException exception thrown if an error occurred while reading
     * the file.
     */
    private HashSet<String> parseRestrictionFile(File restrictionFile) throws IOException {

        HashSet<String> restrictionList = new HashSet<>();

        BufferedReader br = new BufferedReader(new FileReader(restrictionFile));

        String line;
        while ((line = br.readLine()) != null) {

            restrictionList.add(line.trim());

        }

        return restrictionList;
    }

    /**
     * Parses a sif file and populates the maps.
     *
     * @param sifFile the sif file
     * @param restrictionList a list of accessions to restrict to.
     *
     * @throws IOException exception thrown if an error occurred while reading
     * the sif file.
     */
    private void parseSif(File sifFile, HashSet<String> restrictionList) throws IOException {
        
        HashMap<String, HashSet<String>> tempReaction = new HashMap<>();

        BufferedReader br = new BufferedReader(new FileReader(sifFile));

        String line;
        while ((line = br.readLine()) != null) {

            if (line.length() > 10) {

                int firstSpaceIndex = line.indexOf(' ');
                String accession = line.substring(0, firstSpaceIndex);

                if (restrictionList == null || restrictionList.contains(accession)) {

                    allNodes.add(accession);

                    char functionIn = line.charAt(firstSpaceIndex + 1);
                    char functionOut = line.charAt(firstSpaceIndex + 2);

                    String targetsLine = line.substring(10);
                    String[] targets = targetsLine.split(" ");

                    for (String target : targets) {

                        if (!target.equals(accession) && (restrictionList == null || restrictionList.contains(target))) {

                            if (functionIn == 'i' && functionOut == 'o') {

                                HashSet<String> outputs = tempReaction.get(accession);

                                if (outputs == null) {

                                    outputs = new HashSet<>(1);
                                    tempReaction.put(accession, outputs);

                                }

                                outputs.add(target);

                            } else if (functionIn == 'r' && functionOut == 'o') {

                                HashSet<String> outputs = regulation.get(accession);

                                if (outputs == null) {

                                    outputs = new HashSet<>(1);
                                    regulation.put(accession, outputs);

                                }

                                outputs.add(target);

                            } else if (functionIn == 'c' && functionOut == 'o') {

                                HashSet<String> outputs = catalysis.get(accession);

                                if (outputs == null) {

                                    outputs = new HashSet<>(1);
                                    catalysis.put(accession, outputs);

                                }

                                outputs.add(target);

                            } else if (functionIn == 'c' && functionOut == 'n') {

                                HashSet<String> outputs = complex.get(accession);

                                if (outputs == null) {

                                    outputs = new HashSet<>(1);
                                    complex.put(accession, outputs);

                                }

                                outputs.add(target);

                            }
                        }
                    }
                }
            }
        }
        
        for (String accession : tempReaction.keySet()) {
            
            HashSet<String> targets = tempReaction.get(accession);
            HashSet<String> complexes = complex.get(accession);
            
            if (complexes == null) {
                
                reaction.put(accession, targets);
                
            } else {
                
                HashSet<String> filteredTargets = targets.stream()
                        .filter(target -> !complexes.contains(target))
                        .collect(Collectors.toCollection(HashSet::new));
                
                if (!filteredTargets.isEmpty()) {
                    
                    reaction.put(accession, filteredTargets);
                    
                }
            }
        }

        populateNodesList(reaction);
        populateNodesList(catalysis);
        populateNodesList(regulation);
        populateNodesList(complex);
    }
    
    /**
     * Populates the nodes with the accessions in the given map.
     * 
     * @param accessionsMap the accessions map
     */
    private void populateNodesList(HashMap<String, HashSet<String>> accessionsMap) {
        
        accessionsMap.entrySet().stream()
                .forEach(entry -> {
                    allNodes.add(entry.getKey());
                    allNodes.addAll(entry.getValue());
                });
    }

    /**
     * Write the igraph files.
     *
     * @param folder the destination folder
     * @param baseFileName the base name for the edges and vertices files
     *
     * @throws IOException exception thrown if an error occurred while writing
     * the file
     */
    private void writeIGraphFiles(File folder, String baseFileName) throws IOException {

        File edgeFile = new File(folder, baseFileName + "_edges");

        FileOutputStream outputFileStream = new FileOutputStream(edgeFile);
        GZIPOutputStream outputGzipStream = new GZIPOutputStream(outputFileStream);
        OutputStreamWriter outputEncoder = new OutputStreamWriter(outputGzipStream, encoding);

        try (BufferedWriter bw = new BufferedWriter(outputEncoder)) {

            bw.write("from to type");
            bw.newLine();

            writeEdges(bw, reaction, "Reaction");
            writeEdges(bw, catalysis, "Catalysis");
            writeEdges(bw, regulation, "Regulation");
            writeEdges(bw, complex, "Complex");

        }

        File nodesFile = new File(folder, baseFileName + "_vertices");

        outputFileStream = new FileOutputStream(nodesFile);
        outputGzipStream = new GZIPOutputStream(outputFileStream);
        outputEncoder = new OutputStreamWriter(outputGzipStream, encoding);

        try (BufferedWriter bw = new BufferedWriter(outputEncoder)) {

            bw.write("id");
            bw.newLine();

            bw.write(
                    allNodes.stream()
                            .sorted()
                            .collect(Collectors.joining(System.lineSeparator()))
            );

        }

    }

    /**
     * Writes the given edges using the given writer. Writing exceptions are
     * thrown as runtime exception.
     *
     * @param bw the writer
     * @param targetsMap the accession to target map
     * @param category the category of the mapping
     */
    private void writeEdges(BufferedWriter bw, HashMap<String, HashSet<String>> targetsMap, String category) {
        targetsMap.keySet().stream()
                .sorted()
                .forEach(accession -> writeEdges(bw, accession, targetsMap.get(accession), category));

    }

    /**
     * Writes the given edges using the given writer. Writing exceptions are
     * thrown as runtime exception.
     *
     * @param bw the writer
     * @param accession the accession
     * @param targets the targets
     * @param category the category of the mapping
     */
    private void writeEdges(BufferedWriter bw, String accession, HashSet<String> targets, String category) {

        targets.stream()
                .sorted()
                .forEach(target -> writeEdge(bw, accession, target, category));
    }

    /**
     * Writes the given edge using the given writer. Writing exceptions are
     * thrown as runtime exception.
     *
     * @param bw the writer
     * @param accession the accession
     * @param target the target
     * @param category the category of the mapping
     */
    private void writeEdge(BufferedWriter bw, String accession, String target, String category) {

        try {

            StringBuilder sb = new StringBuilder(accession.length() + target.length() + category.length() + 2);
            sb.append(accession).append(' ').append(target).append(' ').append(category);
            bw.write(sb.toString());
            bw.newLine();

        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
